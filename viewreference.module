<?php
// $Id$

/**
 * @file
 * Defines a field type for referencing a view from a node.
 */

/**
 * Implementation of hook_menu().
 */
function viewreference_menu() {
  $items = array();
  $items['viewreference/autocomplete'] = array(
    'title' => 'viewreference autocomplete',
    'page callback' => 'viewreference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function viewreference_theme() {
  return array(
    'viewreference_item_simple' => array(
      'arguments' => array('item' => NULL),
    ),
    'viewreference_item_advanced' => array(
      'arguments' => array('item' => NULL, 'view' => NULL),
    ),
    'viewreference_select' => array(
      'arguments' => array('element' => NULL),
    ),
    'viewreference_autocomplete' => array(
      'arguments' => array('element' => NULL),
    ),
    'viewreference_formatter_default' => array(
      'arguments' => array('element'),
    ),
  );
}

/**
 * Implementation of hook_field_info().
 *
 * Here we indicate that the content module will use its default
 * handling for the view of this field.
 *
 * Callbacks can be omitted if default handing is used.
 * They're included here just so this module can be used
 * as an example for custom modules that might do things
 * differently.
 */
function viewreference_field_info() {
  return array(
    'viewreference' => array(
      'label' => t('View reference'),
      'description' => t('Store an internal identifer for a related view as an integer value.'),
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
        ),
      ),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function viewreference_field_settings($op, $field) {

  switch ($op) {

    case 'form':
      $form = array();
      $form['referenceable_views'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Views to omit from selection choices'),
        '#multiple' => TRUE,
        '#default_value' => is_array($field['referenceable_views']) ? $field['referenceable_views'] : array(),
        '#options' => viewreference_get_list_of_views(),
        '#description' => t('CAREFUL: Unlike other \'reference\' fields, here you must pick which options to hide rather than which options to show.  If you create new views after you submit this form, you must return to this page to make them available to the View Reference fields.  View numbers seen in the autocomplete fields are identifiers internally generated by View Reference fields and do not represent the view outside this context.'),
      );
      return $form;

    case 'save':
      $settings = array('referenceable_views');
      return $settings;

    case 'database columns':
      $columns = array(
        'view_id' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      );
      return $columns;

    case 'views data':
      $data = content_views_field_views_data($field);
      $db_info = content_database_info($field);
      $table_alias = content_views_tablename($field);

      // Swap the filter handler to the 'in' operator.
      $data[$table_alias][$field['field_name'] .'_view_id']['filter']['handler'] = 'views_handler_filter_many_to_one_content';

      return $data;
  }
}

/**
 * Implementation of hook_field().
 */
function viewreference_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'validate':
      $refs = _viewreference_potential_references($field, TRUE);
      foreach ($items as $delta => $item) {
        if (is_array($item) && !empty($item['error_field'])) {
          $error_field = $item['error_field'];
          unset($item['error_field']);
          if (!empty($item['view_id'])) {
            if (!in_array($item['view_id'], array_keys($refs))) {
              form_set_error($error_field, t("%name : This view can't be referenced.", array('%name' => t($field['widget']['label']))));
            }
          }
        }
      }
      return $items;
  }
}

/**
 * Implementation of hook_content_is_empty().
 */
function viewreference_content_is_empty($item, $field) {
  if (empty($item['view_id'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_field_formatter_info().
 */
function viewreference_field_formatter_info() {
  return array(
    'default' => array(
      'label' => t('Default'),
      'field types' => array('viewreference'),
      'multiple values' => CONTENT_HANDLE_CORE,
    ),
  );
}

/**
 * Theme function for 'default' viewreference field formatter.
 *
 */
function theme_viewreference_formatter_default($element) {
  if (!empty($element['#item']['view_id']) && is_numeric($element['#item']['view_id'])) {
    $view = db_fetch_object(db_query(db_rewrite_sql("SELECT name, position FROM {viewreference} WHERE view_id = '%d'"), $element['#item']['view_id']));
    $theview = views_get_view($view->name);
    $output = views_embed_view($view->name, $view->position);
  }
  return $output;
}


/**
 * Implementation of hook_widget_info().
 *
 * We need custom handling of multiple values for the viewreference_select
 * widget because we need to combine them into a options list rather
 * than display multiple elements.
 *
 * We will use the content module's default handling for default value.
 *
 * Callbacks can be omitted if default handing is used.
 * They're included here just so this module can be used
 * as an example for custom modules that might do things
 * differently.
 */
function viewreference_widget_info() {
  return array(
    'viewreference_select' => array(
      'label' => t('Select list'),
      'field types' => array('viewreference'),
      'multiple values' => CONTENT_HANDLE_MODULE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
    'viewreference_autocomplete' => array(
      'label' => t('Autocomplete text field'),
      'field types' => array('viewreference'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of FAPI hook_elements().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see viewreference and userreference).
 */
function viewreference_elements() {
  return array(
    'viewreference_select' => array(
      '#input' => TRUE,
      '#columns' => array('uid'), '#delta' => 0,
      '#process' => array('viewreference_select_process'),
      ),
    'viewreference_autocomplete' => array(
      '#input' => TRUE,
      '#columns' => array('name'), '#delta' => 0,
      '#process' => array('viewreference_autocomplete_process'),
      '#autocomplete_path' => FALSE,
      ),
    );
}

/**
 * Implementation of hook_widget().
 *
 * Attach a single form element to the form. It will be built out and
 * validated in the callback(s) listed in hook_elements. We build it
 * out in the callbacks rather than here in hook_widget so it can be
 * plugged into any module that can provide it with valid
 * $field information.
 *
 * Content module will set the weight, field name and delta values
 * for each form element. This is a change from earlier CCK versions
 * where the widget managed its own multiple values.
 *
 * If there are multiple values for this field, the content module will
 * call this function as many times as needed.
 *
 * @param $form
 *   the entire form array, $form['#node'] holds node information
 * @param $form_state
 *   the form_state, $form_state['values'][$field['field_name']]
 *   holds the field's form values.
 * @param $field
 *   the field array
 * @param $items
 *   array of default values for this field
 * @param $delta
 *   the order of this item in the array of subelements (0, 1, 2, etc)
 *
 * @return
 *   the form item for a single element for this field
 */
function viewreference_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'viewreference_select':
      $element = array(
        '#type' => 'viewreference_select',
        '#default_value' => $items,
      );
      break;

    case 'viewreference_autocomplete':
      $element = array(
        '#type' => 'viewreference_autocomplete',
        '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
        '#value_callback' => 'viewreference_autocomplete_value',
      );
      break;
  }
  return $element;
}

/**
 * Value for a viewreference autocomplete element.
 *
 * Substitute in the view title for the internal view vid.
 */
function viewreference_autocomplete_value($element, $edit = FALSE) {
  $field_key  = $element['#columns'][0];
  if (!empty($element['#default_value'][$field_key])) {
    $vid = $element['#default_value'][$field_key];
    $value = db_result(db_query(db_rewrite_sql("SELECT title FROM {viewreference} WHERE view_id = '%d'"), $vid));
    $value .= ' [view:'. $vid .']';
    return array($field_key => $value);
  }
  return array($field_key => NULL);
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 * The $fields array is in $form['#field_info'][$element['#field_name']].
 */
function viewreference_select_process($element, $edit, $form_state, $form) {
  // The viewreference_select widget doesn't need to create its own
  // element, it can wrap around the optionwidgets_select element.
  // Add a validation step where the value can be unwrapped.
  $field_key  = $element['#columns'][0];
  $element[$field_key] = array(
    '#type' => 'optionwidgets_select',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    '#element_validate' => array('optionwidgets_validate', 'viewreference_select_validate'),

    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#field_name' => $element['#field_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
  );
  return $element;
}

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 */
function viewreference_autocomplete_process($element, $edit, $form_state, $form) {
  // The viewreference autocomplete widget doesn't need to create its own
  // element, it can wrap around the text_textfield element and add an autocomplete
  // path and some extra processing to it.
  // Add a validation step where the value can be unwrapped.
  $field_key  = $element['#columns'][0];

  $element[$field_key] = array(
    '#type' => 'text_textfield',
    '#default_value' => isset($element['#value']) ? $element['#value'] : '',
    '#autocomplete_path' => 'viewreference/autocomplete/'. $element['#field_name'],
    '#element_validate' => array('viewreference_autocomplete_validate'),

    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#field_name' => $element['#field_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
    '#title' => $element['#title'],
    '#required' => $element['#required'],
    '#description' => $element['#description'],
  );
  return $element;
}

/**
 * Validate an select element.
 *
 * Remove the wrapper layer and set the right element's value.
 * We don't know exactly where this element is, so we drill down
 * through the element until we get to our key.
 */
function viewreference_select_validate($element, &$form_state) {
  $field_key = $element['#columns'][0];
  $new_parents = array();
  $value = $form_state['values'];
  foreach ($element['#parents'] as $parent) {
    $value = $value[$parent];
    if ($parent == $field_key) {
      $element['#parents'] = $new_parents;
      form_set_value($element, $value, $form_state);
      break;
    }
    $new_parents[] = $parent;
  }
}

/**
 * Validate an autocomplete element.
 *
 * Remove the wrapper layer and set the right element's value.
 */
function viewreference_autocomplete_validate($element, &$form_state) {
  $field_name = $element['#field_name'];
  $field = content_fields($field_name);
  $field_key  = $element['#columns'][0];
  $delta = $element['#delta'];
  $value = $element['#value'][$field_key];
  $vid = NULL;
  if (!empty($value)) {
    preg_match('/^(?:\s*|(.*) )?\[\s*view\s*:\s*(\d+)\s*\]$/', $value, $matches);
    if (!empty($matches)) {
      // explicit vid
      list(, $title, $vid) = $matches;

      $args[] = $vid;
      $result = db_query(db_rewrite_sql("SELECT title FROM {viewreference} WHERE view_id = '%s'"), $args);

      if (!empty($title) && ($v = db_fetch_object($result)) && $title != $v->title) {  
        form_set_error($element[$field_key], t('%name: Title mismatch. Please check your selection.'), array('%name' => t($element[$field_key]['#title'])));
      }
    }
    else {
      // no explicit vid
      // TODO :
      // the best thing would be to present the user with an additional form,
      // allowing the user to choose between valid candidates with the same title
      // ATM, we pick the first matching candidate...
      $vids = _viewreference_potential_references($field, FALSE, $value, TRUE);
      $vid = (!empty($vids)) ? array_shift(array_keys($vids)) : 0;
    }
  }
  form_set_value($element, $vid, $form_state);
  return $element;
}

/**
 * Implementation of hook_allowed_values().
 */
function viewreference_allowed_values($field) {
  $options = _viewreference_potential_references($field, TRUE);
  
  foreach ($options as $key => $value) {
    $options[$key] = _viewreference_item($field, $value);
  }
  if (!$field['required']) {
    $options = array(0 => '<'. t('none') .'>') + $options;
  }
  return $options;
}

/**
 * Fetch an array of all candidate referenced views,
 * for use in presenting the selection form to the user.
 * 
 */
function _viewreference_potential_references($field, $return_full_views = FALSE, $string = '', $exact_string = false) {
  // build the appropriate query
  $related_views = array();
  $args = array();

  if (is_array($field['referenceable_views'])) {
    foreach ($field['referenceable_views'] as $related_key => $related_view) {
      if ($related_view) {
        $related_views[] = "view_id != %d";
        $args[] = $related_view;
      }
    }
  }

  $related_clause = implode(' AND ', $related_views);

  if (!count($related_views)) {
    $related_clause = " 1 ";
  }

  if (isset($string)) {
    $string_clause = $exact_string ? " AND title = '%s'" : " AND title LIKE '%%%s%'";
    $related_clause = " (". $related_clause .")". $string_clause;
    $args[] = $string;
  }

  $result = db_query(db_rewrite_sql("SELECT view_id, position, name, title FROM {viewreference} WHERE ". $related_clause ." ORDER BY view_id"), $args);

  $rows = array();

  while ($v = db_fetch_object($result)) {
    if ($return_full_views) {
      $rows[$v->view_id] = $v;
    }
    else {
      $rows[$v->view_id] = $v->title;
    }
  }

  return $rows;

}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions
 */
function viewreference_autocomplete($field_name, $string = '') {
  $fields = content_fields();
  $field = $fields[$field_name];
  $matches = array();
  $references = _viewreference_potential_references($field, TRUE, $string);
  foreach ($references as $rowvid => $rowname) {
    $matches[_viewreference_item($field, $rowname) .' [view:'. $rowvid .']'] = _viewreference_item($field, $rowname);
  }
  drupal_json($matches);
}

function _viewreference_item($field, $item, $html = FALSE) {
  $output = theme('viewreference_item_simple', $item);
  $output = $html ? check_plain($output) : $output;
  return $output;
}

function theme_viewreference_item_advanced($item, $field_names, $view) {
  $item_fields = array();
  $item = (array) $item;
  foreach ($item as $delta => $value) {
    // remove link tags (ex : for view titles)
    $value = preg_replace('/<a[^>]*>(.*)<\/a>/iU', '$1', $value);
    if (!empty($value)) {
      $item_fields[] = "<span class='view-field view-data-$field_names[$delta]'>$value</span>";;
    }
  }
  $output = implode(' - ', $item_fields);
  $output = "<span class='view-item view-item-$view->name'>$output</span>";
  return $output;
}

function theme_viewreference_item_simple($item) {
  return $item->title;
}

/**
 * FAPI theme for an individual elements.
 *
 * The textfield or select is already rendered by the
 * textfield or select themes and the html output
 * lives in $element['#children']. Override this theme to
 * make custom changes to the output.
 *
 * $element['#field_name'] contains the field name
 * $element['#delta]  is the position of this element in the group
 */
function theme_viewreference_select($element) {
  return $element['#children'];
}

function theme_viewreference_autocomplete($element) {
  return $element['#children'];
}

/**
 * Builds a table of view references, and returns data as an array
 */
function viewreference_get_list_of_views() {  
  $views = array();
  $loaded_views = views_get_all_views();
  foreach ((array)$loaded_views as $view_name => $view) {
    foreach ((array)$view->display as $display_key => $display_data) {
      // views guy reckons not to use default
      if ($display_key != 'default') {
        // Figure out what the view_id is by doing some queries
        $view_id = db_result(db_query("SELECT view_id FROM {viewreference} WHERE name = '%s' AND position = '%s' ", $view_name, $display_key));
        if (!$view_id) {
          $view_id = db_result(db_query("SELECT MAX(view_id) FROM {viewreference}"))+1;
        }

        // Update database (delete [if possible] then insert)
        db_query("DELETE FROM {viewreference} WHERE view_id = %d", $view_id);
        $title = ucfirst($view_name) .' '. $display_data->display_title;
        db_query("INSERT INTO {viewreference} (view_id, name, position, title) VALUES (%d, '%s', '%s', '%s')", $view_id, $view_name, $display_key, $title);

        // Build return array
        $views[$view_id] = $title;

      }
    }
  }
  return $views;
}